package client

var (
	promptCallAnalyze = `
Я предоставлю тебе транскрипт или краткое содержание нашей ежедневной встречи. Твоя задача — проанализировать его и составить чёткий, действенный план. 

Верни результат СТРОГО в следующем текстовом формате, используя markdown разметку:

# Анализ встречи

## 1. Ключевые обсуждаемые темы
- Тема 1
- Тема 2
- Тема 3

## 2. Задачи к выполнению
- [ ] Задача 1 (Ответственный: Имя, Срок: дата)
- [ ] Задача 2 (Ответственный: Имя)
- [ ] Задача 3 (Срок: дата)

## 3. Открытые вопросы или блокеры
- Вопрос 1
- Вопрос 2
- Блокер 1

## 4. Следующие шаги
1. Шаг 1
2. Шаг 2
3. Шаг 3

Будь кратким и конкретным. Используй только этот шаблон. Не добавляй никакого текста до или после шаблона.
`

	promptAnalyze = `
Ты — модель o3, анализирующая транскрипт собеседования (интервьюер ↔ кандидат).

Твоя задача:
1) Извлечь ВСЕ реальные смысловые вопросы интервьюера.
2) Для КАЖДОГО вопроса определить, дал ли кандидат содержательный ответ или нет.
3) Вернуть результат СТРОГО в формате JSON в конце промпта.

Транскрипт может быть ОЧЕНЬ ДЛИННЫМ (десятки тысяч токенов). Обрабатывай его целиком, не обрезай и не пересказывай. Твоя задача — пройтись по всему тексту и не пропустить ни одного смыслового вопроса, который подходит под правила.

------------------------------------------------------------
                 ЖЁСТКИЕ ПРАВИЛА (не нарушать)
------------------------------------------------------------

1. Вопросом считается ЛЮБОЕ предложение интервьюера со знаком "?"
   которое связано с предметом технического / профессионального обсуждения
   (технологии, опыт, задачи, процесс разработки, архитектура, алгоритмы,
   поведение в рабочих ситуациях и т.п.).

2. ВОПРОСЫ, которые НУЖНО ПОЛНОСТЬЮ ИГНОРИРОВАТЬ (НЕ добавлять в JSON НИ ПРИ КАКИХ УСЛОВИЯХ):

   - Проверка связи/звука:
     «Слышно?», «Нормально слышно?», «Алло?», «Не пропадаю?» и т.п.

   - Организационные вопросы:
     «Все понятно?», «Понятно?», «Продолжаем?», «Дальше поехали?»,
     «Идем дальше?», «Можем двигаться дальше?» и т.п.

   - Вопросы о знании самого объяснения:
     «Ты это знал(а)?», «Знала?», «Это простое?», «Было знакомо?» и т.п.

   - Вопросы вида «есть ли у тебя вопросы»:
     «Какие-то вопросы есть?», «Есть вопросы?», «Остались вопросы?» и т.п.

   - Вопросы-комментарии без смысловой нагрузки:
     «Ок?», «Так?», «Да?», «Верно?», «Понятно?» — если они НЕ добавляют нового технического смысла.

   - Уточнения без нового смысла:
     «То есть как?», «А если так?», «А так можно?» — ЕСЛИ это мелкая реплика,
     непосредственно следующая за более полным вопросом и не добавляющая НОВОЙ
     самостоятельной темы. В таком случае вопрос должен быть учтён только один раз,
     в основной формулировке.

3. Если вопрос НЕ подпадает под исключения из пункта 2 — он ОБЯЗАН быть классифицирован
   и попасть в итоговый JSON-массив "questions".

------------------------------------------------------------
         КАК ИСКАТЬ ВОПРОСЫ И ОТВЕТЫ В БОЛЬШОМ КОНТЕКСТЕ
------------------------------------------------------------

1. Иди по транскрипту ПОСЛЕДОВАТЕЛЬНО, реплика за репликой.

2. Считай вопросом реплику, сказанную ИНТЕРВЬЮЕРОМ, содержащую знак вопроса "?"
   и удовлетворяющую правилам выше (не попадающую под игнор).

3. Для КАЖДОГО такого вопроса:
   - Найди ближайший последующий ответ КАНДИДАТА (один или несколько подряд),
     который по смыслу относится к этому вопросу.
   - Ограничивай поиск ответа разумным окном:
     от момента вопроса и до следующего крупного смыслового вопроса интервьюера
     или явного перехода к другой теме.
   - Не дублируй ответы для разных вопросов.
   - Важно: если интервьюер сам начинает отвечать на свой вопрос
     (объясняет, подсказывает, даёт готовое решение), а кандидат почти ничего не добавляет
     или только поддакивает — считаем, что ответ дал интервьюер, а не кандидат.

4. Если вопрос повторяется много раз с тем же смыслом (интервьюер переформулирует один и тот же вопрос),
   **каждую отдельную формулировку** с "?" рассматривай как ОТДЕЛЬНЫЙ вопрос и оценивай отдельно.
   Но если это одно длинное предложение с несколькими вопросительными хвостами,
   логически относящееся к одному аспекту — объединяй как один вопрос.

------------------------------------------------------------
             КЛАССИФИКАЦИЯ (answered vs unanswered)
------------------------------------------------------------

Вопрос считается ОТВЕЧЁННЫМ (answered), только если выполняется ВСЁ сразу:

- ответ дал ИМЕННО КАНДИДАТ → "answerer"" = "candidate"
- ответ по смыслу относится к вопросу
- точность ответа (accuracy) ≥ 0.7

Если ХОТЬ ОДНО из условий не выполняется, вопрос считается НЕотвеченным.

Если кандидат говорит фразы вида:
	•	«нет / не знаю / не помню / затрудняюсь / не сталкивался»
то:
	•	answerer = “candidate”
	•	accuracy = <= 0.2
	•	вопрос считается НЕотвеченным
	•	reason = “candidate does not know”

Если кандидат лишь подтвердил отсутствие знания это НЕ является ответом.
Даже если модель понимает смысл вопроса — accuracy НЕ может быть высокой,
потому что содержательного ответа нет.

------------------------------------------------------------
                 СЛУЧАИ unanswered (ОБЯЗАТЕЛЬНО)
------------------------------------------------------------

Вопрос должен быть помечен как НЕотвеченный (unanswered), если:

- ответ дал интервьюер (он же всё объяснил) → "answerer" ≠ "candidate"
- кандидат ушёл в сторону, не ответил по существу
- кандидат сказал «не знаю», «не помню», «затрудняюсь ответить» и т.п.
- модель оценивает соответствие ответа вопросу как accuracy < 0.7
- модель не уверена, был ли вообще ответ на этот вопрос

Во всех таких случаях:
- "accuracy" должно быть < 0.7
- поле "reason" ОБЯЗАТЕЛЬНО должно содержать понятное объяснение:
  - "accuracy < 0.7"
  - "no clear answer from candidate"
  - "answer by interviewer"
  - "candidate avoided question"
  - или другую короткую, но конкретную причину.

------------------------------------------------------------
                   ПРАВИЛА ОЦЕНКИ accuracy
------------------------------------------------------------

Оценивай accuracy как меру соответствия ответа кандидата заданному вопросу
по смыслу, полноте и корректности:

- 1.0 → полный, точный, развёрнутый ответ, без заметных ошибок
- 0.7–0.9 → хороший, но не идеальный/неполный ответ
- 0.7 → минимальный порог, чтобы считать вопрос отвечённым
- 0.3–0.7 → частичный или с существенными упущениями/ошибками → вопрос считается НЕотвеченным
- 0.0–0.2 → «не знаю», явный уход в сторону, ответ противоречит вопросу → вопрос НЕотвеченный

Если у тебя сомнения, достиг ли ответ уровня 0.7 — СНИЖАЙ оценку, а не завышай.
Лучше ошибиться в сторону unanswered.

Если кандидат говорит фразы вида:
	•	«нет / не знаю / не помню / затрудняюсь / не сталкивался»
то:
	•	answerer = “candidate”
	•	accuracy = <= 0.2
	•	вопрос считается НЕотвеченным
	•	reason = “candidate does not know”

------------------------------------------------------------
          ИНСТРУКЦИИ ДЛЯ МОДЕЛИ o3 (РЕЗОННЫЙ PIPELINE)
------------------------------------------------------------

Работай по внутренним шагам (chain-of-thought), НО:
- НЕ выводи свои рассуждения наружу.
- Во внешнем ответе должен быть ТОЛЬКО JSON нужной структуры.

Рекомендуемый внутренний pipeline (НЕ выводить):

1) Пройди по транскрипту и отметь все реплики интервьюера с "?".
2) Отфильтруй те, что подходят под исключения (связь, small talk, «все понятно?» и т.п.).
3) Для каждого оставшегося вопроса:
   - Сформулируй его нормализованную текстовую версию (можно слегка почистить повторы и мусор).
   - Найди связанный ответ кандидата (или отсутствие такового).
   - Оцени соответствие ответа вопросу и выставь accuracy.
   - Определи answerer:
       - "candidate", если основное содержательное объяснение дал кандидат.
       - "interviewer", если за кандидата ответил интервьюер.
       - "unknown", если не ясно.
   - На основе этого реши, считать вопрос отвечённым (accuracy ≥ 0.7 и answerer="candidate")
     или НЕотвеченным.
   - Заполни reason:
       - для answered можно писать кратко: "answered by candidate with accuracy >= 0.7",
       - для unanswered — одну из причин из списка выше.

4) После обработки всех вопросов СФОРМИРУЙ ОДИН-ЕДИНСТВЕННЫЙ JSON-объект
   строго по структуре ниже.

------------------------------------------------------------
                 ВАЖНО — ТОЛЬКО ОДИН МАССИВ
------------------------------------------------------------

- Должен быть **РОВНО ОДИН массив** questions.
- Никаких дополнительных массивов (answered, unanswered, meta, и т.п.) выводить НЕЛЬЗЯ.
- Никакого текста до или после JSON, НИКАКИХ комментариев.
- Ответ ДОЛЖЕН быть валидным JSON-объектом верхнего уровня.

------------------------------------------------------------
                     СТРУКТУРА JSON (НЕ МЕНЯТЬ)
------------------------------------------------------------

Итоговый ответ ДОЛЖЕН ИМЕТЬ СТРОГО следующую структуру:

{
  "questions": [
    {
      "question": "string",
      "full_answer": "полный текст ответа кандидата (если есть; иначе пустая строка)",
      "accuracy": 0.0,
      "questioner": "interviewer",
      "answerer": "candidate",
      "reason": "string (например: 'answered by candidate with accuracy >= 0.7', 'accuracy < 0.7', 'no clear answer from candidate', 'answer by interviewer')"
    }
  ]
}

Где:
- questioner ВСЕГДА "interviewer".
- answerer:
  - "candidate" — если основной ответ дал кандидат,
  - "interviewer" — если фактический ответ дал интервьюер,
  - "unknown" — если непонятно, кто ответил или ответа нет.
- full_answer — только реплики кандидата, относящиеся к этому вопросу.
  Если кандидат не ответил — ставь пустую строку "".
- reason — ОБЯЗАТЕЛЕН для каждого вопроса (и answered, и unanswered).

ЕЩЁ РАЗ: ВЫВЕДИ ТОЛЬКО ОДИН ВАЛИДНЫЙ JSON-ОБЪЕКТ С ПОЛЕМ "questions".

`

	transcriptHeader = `
----------------------------------------------------------------------
                     ТРАНСКРИПТ ДЛЯ АНАЛИЗА
----------------------------------------------------------------------

	%v
`
	promptAnalyzeEN = `
You are analyzing an interview transcript (interviewer ↔ candidate).

GOAL: extract ALL meaningful real questions asked by the interviewer and classify
each one as answered or UNanswered by the candidate.

OUTPUT FORMAT — strictly ONLY valid JSON according to the structure at the end of this prompt.

----------------------------------------------------------------------
                           HARD RULES (do not violate)
----------------------------------------------------------------------

1. A question is ANY sentence from the interviewer that contains a question mark "?"
   and is related to the subject of the technical discussion.

2. QUESTIONS THAT MUST BE COMPLETELY IGNORED (do NOT add them anywhere):

   - Connection/audio checks:
     “Do you hear me?”, “Is the sound okay?”, “Hello?”
   - Organizational questions:
     “Is everything clear?”, “Clear?”, “Shall we continue?”,
     “Move on?”, “Shall we go further?”
   - Knowledge-check questions:
     “Did you know this?”, “You knew?”, “Is this simple?”
   - “Do you have any questions?” type:
     “Any questions?”, “Do you have questions?”
   - Comment-questions:
     “Ok?”, “Like this?” — if they do not add semantic meaning.
   - Rhetorical or emotional questions:
     “Right?”, “Yes?”, “Clear?”
   - Clarifications without new meaning:
     “Meaning what?”, “What if this?” — IF they are part of the previous question.

3. If a question does NOT fall under exclusions — it MUST be classified.

4. A question is considered ANSWERED ONLY if:

   - the answer was given SPECIFICALLY by the CANDIDATE (answerer="candidate"), AND
   - the answer is semantically related to the question, AND
   - accuracy >= 0.7.

5. IF:
   - the interviewer gave the answer, OR
   - the candidate deviated from the topic, OR
   - said “don’t know”, “don’t remember”, “not sure”, OR
   - accuracy < 0.7, OR
   - the model is unsure whether the question was answered
   → then the question MUST be placed into questions_unanswered.

6. Only questions where answerer="candidate" may appear in the answered array.

----------------------------------------------------------------------
                     ACCURACY EVALUATION RULES
----------------------------------------------------------------------

- 1.0 → full, correct, precise answer, with no errors
- 0.7–0.9 → good but incomplete answer
- 0.7 → minimal threshold to consider a question answered
- 0.3–0.7 → partial or flawed answer → unanswered
- 0.0–0.2 → “don’t know”, irrelevant, or incorrect answer → unanswered

----------------------------------------------------------------------
                     JSON STRUCTURE (DO NOT CHANGE)
----------------------------------------------------------------------

{
  "questions": [
    {
      "question": "string",
      "full_answer": "full text of the candidate's answer",
      "accuracy": 0.0,
      "questioner": "interviewer",
      "answerer": "candidate",
      "reason": "string (e.g. 'no clear answer from candidate', 'accuracy < 0.6', 'candidate avoided question')"
    }
  ]
}
`

	transcriptHeaderEN = `
----------------------------------------------------------------------
					TRANSCRIPT FOR ANALYSIS
----------------------------------------------------------------------

	%v
`
)

func getAnalyzePrompt(lang string) string {
	switch lang {
	case "en":
		return promptAnalyzeEN
	default:
		return promptAnalyze
	}
}

func getTranscriptPrompt(lang string) string {
	switch lang {
	case "en":
		return transcriptHeaderEN
	default:
		return transcriptHeader
	}
}
